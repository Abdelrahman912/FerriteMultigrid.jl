var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J. B. Schroder. Generalizing Smoothed Aggregation-Based Algebraic Multigrid. PhD dissertation, University of Illinois at Urbana-Champaign (Urbana, Illinois, 2010).\n\n\n\nR. Tielen, M. Möller, D. Göddeke and C. Vuik, p-multigrid methods and their comparison to h-multigrid methods within Isogeometric Analysis. Computer Methods in Applied Mechanics and Engineering 372, 113347 (2020).\n\n\n\n","category":"page"},{"location":"tutorials/linear_elasticity/#tutorial-linear-elasticity","page":"Linear Elasticity","title":"Linear Elasticity","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"(Image: )","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Figure 1: Linear elastically deformed 1mm times 1mm Ferrite logo.","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"note: Note\nThe full explanation for the underlying FEM theory in this example can be found in the Linear Elasticity tutorial of the Ferrite.jl documentation.","category":"page"},{"location":"tutorials/linear_elasticity/#Implementation","page":"Linear Elasticity","title":"Implementation","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The following code is based on the Linear Elasticity tutorial from the Ferrite.jl documentation, with some comments removed for brevity. There are two main modifications:","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Second-order Lagrange shape functions are used for field approximation: ip = Lagrange{RefTriangle,2}()^2.\nFour quadrature points are used to accommodate the second-order shape functions: qr = QuadratureRule{RefTriangle}(4).","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"using Ferrite, FerriteGmsh, SparseArrays\nusing Downloads: download\n\nEmod = 200.0e3 # Young's modulus [MPa]\nν = 0.3        # Poisson's ratio [-]\n\nGmod = Emod / (2(1 + ν))  # Shear modulus\nKmod = Emod / (3(1 - 2ν)) # Bulk modulus\n\nC = gradient(ϵ -> 2 * Gmod * dev(ϵ) + 3 * Kmod * vol(ϵ), zero(SymmetricTensor{2,2}))\n\nfunction assemble_external_forces!(f_ext, dh, facetset, facetvalues, prescribed_traction)\n    # Create a temporary array for the facet's local contributions to the external force vector\n    fe_ext = zeros(getnbasefunctions(facetvalues))\n    for facet in FacetIterator(dh, facetset)\n        # Update the facetvalues to the correct facet number\n        reinit!(facetvalues, facet)\n        # Reset the temporary array for the next facet\n        fill!(fe_ext, 0.0)\n        # Access the cell's coordinates\n        cell_coordinates = getcoordinates(facet)\n        for qp in 1:getnquadpoints(facetvalues)\n            # Calculate the global coordinate of the quadrature point.\n            x = spatial_coordinate(facetvalues, qp, cell_coordinates)\n            tₚ = prescribed_traction(x)\n            # Get the integration weight for the current quadrature point.\n            dΓ = getdetJdV(facetvalues, qp)\n            for i in 1:getnbasefunctions(facetvalues)\n                Nᵢ = shape_value(facetvalues, qp, i)\n                fe_ext[i] += tₚ ⋅ Nᵢ * dΓ\n            end\n        end\n        # Add the local contributions to the correct indices in the global external force vector\n        assemble!(f_ext, celldofs(facet), fe_ext)\n    end\n    return f_ext\nend\n\nfunction assemble_cell!(ke, cellvalues, C)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # Get the integration weight for the quadrature point\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:getnbasefunctions(cellvalues)\n            # Gradient of the test function\n            ∇Nᵢ = shape_gradient(cellvalues, q_point, i)\n            for j in 1:getnbasefunctions(cellvalues)\n                # Symmetric gradient of the trial function\n                ∇ˢʸᵐNⱼ = shape_symmetric_gradient(cellvalues, q_point, j)\n                ke[i, j] += (∇Nᵢ ⊡ C ⊡ ∇ˢʸᵐNⱼ) * dΩ\n            end\n        end\n    end\n    return ke\nend\n\nfunction assemble_global!(K, dh, cellvalues, C)\n    # Allocate the element stiffness matrix\n    n_basefuncs = getnbasefunctions(cellvalues)\n    ke = zeros(n_basefuncs, n_basefuncs)\n    # Create an assembler\n    assembler = start_assemble(K)\n    # Loop over all cells\n    for cell in CellIterator(dh)\n        # Update the shape function gradients based on the cell coordinates\n        reinit!(cellvalues, cell)\n        # Reset the element stiffness matrix\n        fill!(ke, 0.0)\n        # Compute element contribution\n        assemble_cell!(ke, cellvalues, C)\n        # Assemble ke into K\n        assemble!(assembler, celldofs(cell), ke)\n    end\n    return K\nend\n\nfunction linear_elasticity_2d(C)\n    logo_mesh = \"logo.geo\"\n    asset_url = \"https://raw.githubusercontent.com/Ferrite-FEM/Ferrite.jl/gh-pages/assets/\"\n    isfile(logo_mesh) || download(string(asset_url, logo_mesh), logo_mesh)\n\n    grid = togrid(logo_mesh)\n    addfacetset!(grid, \"top\", x -> x[2] ≈ 1.0) # facets for which x[2] ≈ 1.0 for all nodes\n    addfacetset!(grid, \"left\", x -> abs(x[1]) < 1.0e-6)\n    addfacetset!(grid, \"bottom\", x -> abs(x[2]) < 1.0e-6)\n\n    dim = 2\n    order = 2 # quadratic interpolation\n    ip = Lagrange{RefTriangle,order}()^dim # vector valued interpolation\n\n    qr = QuadratureRule{RefTriangle}(4) # 4 quadrature point\n    qr_face = FacetQuadratureRule{RefTriangle}(1)\n\n    cellvalues = CellValues(qr, ip)\n    facetvalues = FacetValues(qr_face, ip)\n\n    dh = DofHandler(grid)\n    add!(dh, :u, ip)\n    close!(dh)\n\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"bottom\"), (x, t) -> 0.0, 2))\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"left\"), (x, t) -> 0.0, 1))\n    close!(ch)\n\n    traction(x) = Vec(0.0, 20.0e3 * x[1])\n\n    A = allocate_matrix(dh)\n    assemble_global!(A, dh, cellvalues, C)\n\n    b = zeros(ndofs(dh))\n    assemble_external_forces!(b, dh, getfacetset(grid, \"top\"), facetvalues, traction)\n    apply!(A, b, ch)\n\n    return A, b, dh, cellvalues, ch\nend","category":"page"},{"location":"tutorials/linear_elasticity/#Near-Null-Space-(NNS)","page":"Linear Elasticity","title":"Near Null Space (NNS)","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"In multigrid methods for problems with vector-valued unknowns, such as linear elasticity, the near null space represents the low energy mode or the smooth error that needs to be captured in the coarser grid when using SA-AMG (Smoothed Aggregation Algebraic Multigrid), more on the topic can be found  in Schroder [1].","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"For 2D linear elasticity problems, the rigid body modes are:","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Translation in the x-direction,\nTranslation in the y-direction,\nRotation about the z-axis (i.e., x_3): each point (x, y) is mapped to (-y, x).","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The function create_nns constructs the NNS matrix B ∈ ℝ^{n × 3}, where n is the number of degrees of freedom (DOFs) for the case of p = 1 (i.e., linear interpolation), because B is only relevant for AMG.","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"function create_nns(dh)\n    ##Ndof = ndofs(dh)\n    grid = dh.grid\n    Ndof = 2 * (grid.nodes |> length) # nns at p = 1 for AMG\n    B = zeros(Float64, Ndof, 3)\n    B[1:2:end, 1] .= 1 # x - translation\n    B[2:2:end, 2] .= 1 # y - translation\n\n    # in-plane rotation (x,y) → (-y,x)\n    coords = reduce(hcat, grid.nodes .|> (n -> n.x |> collect))' # convert nodes to 2d array\n    y = coords[:, 2]\n    x = coords[:, 1]\n    B[1:2:end, 3] .= -y\n    B[2:2:end, 3] .= x\n    return B\nend","category":"page"},{"location":"tutorials/linear_elasticity/#Setup-the-linear-elasticity-problem","page":"Linear Elasticity","title":"Setup the linear elasticity problem","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Load FerriteMultigrid to access the p-multigrid solver.","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"using FerriteMultigrid","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Construct the linear elasticity problem with 2nd order polynomial shape functions.","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"A, b, dh, cellvalues, ch = linear_elasticity_2d(C);\nnothing #hide","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Construct the near null space (NNS) matrix","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"B = create_nns(dh)","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"danger: Danger\nSince NNS matrix is only relevant for AMG, and it is not used in the p-multigrid solver, therefore, B has to provided using linear field approximation (i.e., p = 1) when using AMG as the coarse solver, otherwise (e.g., using Pinv as the coarse solver), then we don't have to provide it.","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Construct the finite element space mathcalV_hp = 2","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"fe_space = FESpace(dh, cellvalues, ch)","category":"page"},{"location":"tutorials/linear_elasticity/#P-multigrid-Configuration","page":"Linear Elasticity","title":"P-multigrid Configuration","text":"","category":"section"},{"location":"tutorials/linear_elasticity/#1.-Galerkin-Coarsening-Strategy","page":"Linear Elasticity","title":"1. Galerkin Coarsening Strategy","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"config_gal = pmultigrid_config(coarse_strategy = Galerkin())\nx_gal, res_gal = solve(A, b,fe_space, config_gal;B = B, log=true, rtol = 1e-10)","category":"page"},{"location":"tutorials/linear_elasticity/#2.-Rediscretization-Coarsening-Strategy","page":"Linear Elasticity","title":"2. Rediscretization Coarsening Strategy","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"# Rediscretization Coarsening Strategy\nconfig_red = pmultigrid_config(coarse_strategy = Rediscretization(LinearElasticityMultigrid(C)))\nx_red, res_red = solve(A, b, fe_space, config_red; B = B, log=true, rtol = 1e-10)","category":"page"},{"location":"tutorials/linear_elasticity/#Test-the-solution","page":"Linear Elasticity","title":"Test the solution","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"using Test\n@testset \"Linear Elasticity Example\" begin\n    println(\"Final residual with Galerkin coarsening: \", res_gal[end])\n    @test A * x_gal ≈ b\n    println(\"Final residual with Rediscretization coarsening: \", res_red[end])\n    @test A * x_red ≈ b\nend","category":"page"},{"location":"tutorials/linear_elasticity/#linear-elasticity-plain-program","page":"Linear Elasticity","title":"Plain program","text":"","category":"section"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Here follows a version of the program without any comments. The file is also available here: linear_elasticity.jl.","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"using Ferrite, FerriteGmsh, SparseArrays\nusing Downloads: download\n\nEmod = 200.0e3 # Young's modulus [MPa]\nν = 0.3        # Poisson's ratio [-]\n\nGmod = Emod / (2(1 + ν))  # Shear modulus\nKmod = Emod / (3(1 - 2ν)) # Bulk modulus\n\nC = gradient(ϵ -> 2 * Gmod * dev(ϵ) + 3 * Kmod * vol(ϵ), zero(SymmetricTensor{2,2}))\n\nfunction assemble_external_forces!(f_ext, dh, facetset, facetvalues, prescribed_traction)\n    # Create a temporary array for the facet's local contributions to the external force vector\n    fe_ext = zeros(getnbasefunctions(facetvalues))\n    for facet in FacetIterator(dh, facetset)\n        # Update the facetvalues to the correct facet number\n        reinit!(facetvalues, facet)\n        # Reset the temporary array for the next facet\n        fill!(fe_ext, 0.0)\n        # Access the cell's coordinates\n        cell_coordinates = getcoordinates(facet)\n        for qp in 1:getnquadpoints(facetvalues)\n            # Calculate the global coordinate of the quadrature point.\n            x = spatial_coordinate(facetvalues, qp, cell_coordinates)\n            tₚ = prescribed_traction(x)\n            # Get the integration weight for the current quadrature point.\n            dΓ = getdetJdV(facetvalues, qp)\n            for i in 1:getnbasefunctions(facetvalues)\n                Nᵢ = shape_value(facetvalues, qp, i)\n                fe_ext[i] += tₚ ⋅ Nᵢ * dΓ\n            end\n        end\n        # Add the local contributions to the correct indices in the global external force vector\n        assemble!(f_ext, celldofs(facet), fe_ext)\n    end\n    return f_ext\nend\n\nfunction assemble_cell!(ke, cellvalues, C)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # Get the integration weight for the quadrature point\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:getnbasefunctions(cellvalues)\n            # Gradient of the test function\n            ∇Nᵢ = shape_gradient(cellvalues, q_point, i)\n            for j in 1:getnbasefunctions(cellvalues)\n                # Symmetric gradient of the trial function\n                ∇ˢʸᵐNⱼ = shape_symmetric_gradient(cellvalues, q_point, j)\n                ke[i, j] += (∇Nᵢ ⊡ C ⊡ ∇ˢʸᵐNⱼ) * dΩ\n            end\n        end\n    end\n    return ke\nend\n\nfunction assemble_global!(K, dh, cellvalues, C)\n    # Allocate the element stiffness matrix\n    n_basefuncs = getnbasefunctions(cellvalues)\n    ke = zeros(n_basefuncs, n_basefuncs)\n    # Create an assembler\n    assembler = start_assemble(K)\n    # Loop over all cells\n    for cell in CellIterator(dh)\n        # Update the shape function gradients based on the cell coordinates\n        reinit!(cellvalues, cell)\n        # Reset the element stiffness matrix\n        fill!(ke, 0.0)\n        # Compute element contribution\n        assemble_cell!(ke, cellvalues, C)\n        # Assemble ke into K\n        assemble!(assembler, celldofs(cell), ke)\n    end\n    return K\nend\n\nfunction linear_elasticity_2d(C)\n    logo_mesh = \"logo.geo\"\n    asset_url = \"https://raw.githubusercontent.com/Ferrite-FEM/Ferrite.jl/gh-pages/assets/\"\n    isfile(logo_mesh) || download(string(asset_url, logo_mesh), logo_mesh)\n\n    grid = togrid(logo_mesh)\n    addfacetset!(grid, \"top\", x -> x[2] ≈ 1.0) # facets for which x[2] ≈ 1.0 for all nodes\n    addfacetset!(grid, \"left\", x -> abs(x[1]) < 1.0e-6)\n    addfacetset!(grid, \"bottom\", x -> abs(x[2]) < 1.0e-6)\n\n    dim = 2\n    order = 2 # quadratic interpolation\n    ip = Lagrange{RefTriangle,order}()^dim # vector valued interpolation\n\n    qr = QuadratureRule{RefTriangle}(4) # 4 quadrature point\n    qr_face = FacetQuadratureRule{RefTriangle}(1)\n\n    cellvalues = CellValues(qr, ip)\n    facetvalues = FacetValues(qr_face, ip)\n\n    dh = DofHandler(grid)\n    add!(dh, :u, ip)\n    close!(dh)\n\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"bottom\"), (x, t) -> 0.0, 2))\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"left\"), (x, t) -> 0.0, 1))\n    close!(ch)\n\n    traction(x) = Vec(0.0, 20.0e3 * x[1])\n\n    A = allocate_matrix(dh)\n    assemble_global!(A, dh, cellvalues, C)\n\n    b = zeros(ndofs(dh))\n    assemble_external_forces!(b, dh, getfacetset(grid, \"top\"), facetvalues, traction)\n    apply!(A, b, ch)\n\n    return A, b, dh, cellvalues, ch\nend\n\nfunction create_nns(dh)\n    ##Ndof = ndofs(dh)\n    grid = dh.grid\n    Ndof = 2 * (grid.nodes |> length) # nns at p = 1 for AMG\n    B = zeros(Float64, Ndof, 3)\n    B[1:2:end, 1] .= 1 # x - translation\n    B[2:2:end, 2] .= 1 # y - translation\n\n    # in-plane rotation (x,y) → (-y,x)\n    coords = reduce(hcat, grid.nodes .|> (n -> n.x |> collect))' # convert nodes to 2d array\n    y = coords[:, 2]\n    x = coords[:, 1]\n    B[1:2:end, 3] .= -y\n    B[2:2:end, 3] .= x\n    return B\nend\n\nusing FerriteMultigrid\n\nA, b, dh, cellvalues, ch = linear_elasticity_2d(C);\n\nB = create_nns(dh)\n\nfe_space = FESpace(dh, cellvalues, ch)\n\nconfig_gal = pmultigrid_config(coarse_strategy = Galerkin())\nx_gal, res_gal = solve(A, b,fe_space, config_gal;B = B, log=true, rtol = 1e-10)\n\n# Rediscretization Coarsening Strategy\nconfig_red = pmultigrid_config(coarse_strategy = Rediscretization(LinearElasticityMultigrid(C)))\nx_red, res_red = solve(A, b, fe_space, config_red; B = B, log=true, rtol = 1e-10)\n\nusing Test\n@testset \"Linear Elasticity Example\" begin\n    println(\"Final residual with Galerkin coarsening: \", res_gal[end])\n    @test A * x_gal ≈ b\n    println(\"Final residual with Rediscretization coarsening: \", res_red[end])\n    @test A * x_red ≈ b\nend","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"","category":"page"},{"location":"tutorials/linear_elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api-reference/multigrid_problems/#Multigrid-Problems","page":"Multigrid Problems","title":"Multigrid Problems","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#Interface","page":"Multigrid Problems","title":"Interface","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.AbstractPMultigrid","page":"Multigrid Problems","title":"FerriteMultigrid.AbstractPMultigrid","text":"abstract type AbstractPMultigrid\n\nThis is an abstract type that can be extended to when Rediscretization strategy is used as coarsening strategy, otherwise it's not required.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.assemble","page":"Multigrid Problems","title":"FerriteMultigrid.assemble","text":"assemble(problem::AbstractPMultigrid, fe_space::FESpace)\n\nThe interface that needs to be implemented to define the Rediscretization strategy for a specific problem type.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/multigrid_problems/#Diffusion","page":"Multigrid Problems","title":"Diffusion","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.DiffusionMultigrid","page":"Multigrid Problems","title":"FerriteMultigrid.DiffusionMultigrid","text":"DiffusionMultigrid{C} <: AbstractPMultigrid\n\nThis struct represents a multigrid problem for diffusion equations with a coefficient C.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/multigrid_problems/#Linear-Elasticity","page":"Multigrid Problems","title":"Linear Elasticity","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.LinearElasticityMultigrid","page":"Multigrid Problems","title":"FerriteMultigrid.LinearElasticityMultigrid","text":"LinearElasticityMultigrid{TC} <: AbstractPMultigrid\n\nThis struct represents a multigrid problem for linear elasticity equations with a material stiffness tensor `TC\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#Multigrid-Configuration","page":"Multigrid Configuration","title":"Multigrid Configuration","text":"","category":"section"},{"location":"api-reference/pmg_config/#FerriteMultigrid.PMultigridConfiguration","page":"Multigrid Configuration","title":"FerriteMultigrid.PMultigridConfiguration","text":"PMultigridConfiguration{TC<:AbstractCoarseningStrategy, TP<:AbstractProjectionStrategy}\n\nThis struct represents the configuration for the polynomial multigrid method.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#FerriteMultigrid.pmultigrid_config","page":"Multigrid Configuration","title":"FerriteMultigrid.pmultigrid_config","text":"pmultigrid_config(;coarse_strategy = Galerkin(), proj_strategy = DirectProjection())\n\nThis function is the main api to instantiate PMultigridConfiguration.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/pmg_config/#Coarsening-Strategy","page":"Multigrid Configuration","title":"Coarsening Strategy","text":"","category":"section"},{"location":"api-reference/pmg_config/#FerriteMultigrid.Galerkin","page":"Multigrid Configuration","title":"FerriteMultigrid.Galerkin","text":"Galerkin <: AbstractCoarseningStrategy\n\nGalerkin coarsening operator can be defined as follows:\n\nA_hp-1 = mathcalI_p^p-1 A_hp mathcalI_p-1^p\n\nand according to Tielen et al. [2] mathcalI_p-1^p is the interpolation operator from the coarse space to the fine space and is defined as follows:\n\nmathcalI_p-1^p (mathbfv_p-1) = (mathbfM_p)^-1 mathbfP_p-1^p  mathbfv_p-1\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#FerriteMultigrid.Rediscretization","page":"Multigrid Configuration","title":"FerriteMultigrid.Rediscretization","text":"Rediscretization{TP <: AbstractPMultigrid} <: AbstractCoarseningStrategy\n\nThis struct represents a coarsening strategy that uses the assemble function to obtain the coarse grid operator. It is used when the Rediscretization strategy is specified in the pmultigrid_config. It requires the problem type TP to be a subtype of AbstractPMultigrid.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#Projection-Strategy","page":"Multigrid Configuration","title":"Projection Strategy","text":"","category":"section"},{"location":"api-reference/pmg_config/#FerriteMultigrid.DirectProjection","page":"Multigrid Configuration","title":"FerriteMultigrid.DirectProjection","text":"DirectProjection <: AbstractProjectionStrategy\n\nThis struct represents a direct projection from mathcalV_hp to mathcalV_hp=1. \n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#FerriteMultigrid.StepProjection","page":"Multigrid Configuration","title":"FerriteMultigrid.StepProjection","text":"StepProjection <: AbstractProjectionStrategy\n\nThis struct represents a projection from mathcalV_hp to mathcalV_hp-step, where step is a positive integer. It is used to reduce the polynomial order by a fixed step size until p = 1.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/fe/#Finite-Element","page":"Finite Element","title":"Finite Element","text":"","category":"section"},{"location":"api-reference/fe/#Finite-Element-Space","page":"Finite Element","title":"Finite Element Space","text":"","category":"section"},{"location":"api-reference/fe/#FerriteMultigrid.FESpace","page":"Finite Element","title":"FerriteMultigrid.FESpace","text":"FESpace{DH<:AbstractDofHandler, CV<:AbstractCellValues, CH<:ConstraintHandler}\n\nA structure that encapsulates the finite element space.\n\nFields\n\ndh::DH: Degree-of-freedom handler \ncv::CV: Cell values\nch::CH: Constraint handler.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/multilevel/#Multilevel","page":"Multilevel","title":"Multilevel","text":"","category":"section"},{"location":"api-reference/multilevel/#Solve","page":"Multilevel","title":"Solve","text":"","category":"section"},{"location":"api-reference/multilevel/#CommonSolve.solve","page":"Multilevel","title":"CommonSolve.solve","text":"CommonSolve.solve(args...; kwargs...)\n\nSolves an equation or other mathematical problem using the algorithm specified in the arguments. Generally, the interface is:\n\nCommonSolve.solve(prob::ProblemType,alg::SolverType; kwargs...)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms.\n\nBy default, solve defaults to using solve! on the iterator form, i.e.:\n\nsolve(args...; kwargs...) = solve!(init(args...; kwargs...))\n\n\n\n\n\nsolve(prob::OptimizationProblem, alg::AbstractOptimizationAlgorithm, args...; kwargs...)\n\nKeyword Arguments\n\nThe arguments to solve are common across all of the optimizers. These common arguments are:\n\nmaxiters: the maximum number of iterations\nmaxtime: the maximum amount of time (typically in seconds) the optimization runs for\nabstol: absolute tolerance in changes of the objective value\nreltol: relative tolerance  in changes of the objective value\ncallback: a callback function\n\nSome optimizer algorithms have special keyword arguments documented in the solver portion of the documentation and their respective documentation. These arguments can be passed as kwargs... to solve. Similarly, the special keyword arguments for the local_method of a global optimizer are passed as a NamedTuple to local_options.\n\nOver time, we hope to cover more of these keyword arguments under the common interface.\n\nA warning will be shown if a common argument is not implemented for an optimizer.\n\nCallback Functions\n\nThe callback function callback is a function that is called after every optimizer step. Its signature is:\n\ncallback = (state, loss_val) -> false\n\nwhere state is an OptimizationState and stores information for the current iteration of the solver and loss_val is loss/objective value. For more information about the fields of the state look at the OptimizationState documentation. The callback should return a Boolean value, and the default should be false, so the optimization stops if it returns true.\n\nCallback Example\n\nHere we show an example of a callback function that plots the prediction at the current value of the optimization variables. For a visualization callback, we would need the prediction at the current parameters i.e. the solution of the ODEProblem prob. So we call the predict function within the callback again.\n\nfunction predict(u)\n    Array(solve(prob, Tsit5(), p = u))\nend\n\nfunction loss(u, p)\n    pred = predict(u)\n    sum(abs2, batch .- pred)\nend\n\ncallback = function (state, l; doplot = false) #callback function to observe training\n    display(l)\n    # plot current prediction against data\n    if doplot\n        pred = predict(state.u)\n        pl = scatter(t, ode_data[1, :], label = \"data\")\n        scatter!(pl, t, pred[1, :], label = \"prediction\")\n        display(plot(pl))\n    end\n    return false\nend\n\nIf the chosen method is a global optimizer that employs a local optimization method, a similar set of common local optimizer arguments exists. Look at MLSL or AUGLAG from NLopt for an example. The common local optimizer arguments are:\n\nlocal_method: optimizer used for local optimization in global method\nlocal_maxiters: the maximum number of iterations\nlocal_maxtime: the maximum amount of time (in seconds) the optimization runs for\nlocal_abstol: absolute tolerance in changes of the objective value\nlocal_reltol: relative tolerance  in changes of the objective value\nlocal_options: NamedTuple of keyword arguments for local optimizer\n\n\n\n\n\nsolve(A::AbstractMatrix, b::Vector, fe_space::FESpace, pgrid_config::PMultigridConfiguration = pmultigrid_config(), pcoarse_solvertype::Type{<:CoarseSolver} = SmoothedAggregationCoarseSolver, args...; kwargs...)\n\nThis function solves the linear system Ax = b using polynomial multigrid methods with a coarse solver of type pcoarse_solvertype.\n\nFields\n\nA: The system matrix.\nb: The right-hand side vector.\nfe_space: See FESpace for details on the finite element space.   \npgrid_config: Configuration for the polynomial multigrid method, see PMultigridConfiguration for details.\npcoarse_solvertype: The type of coarse solver to use (e.g., SmoothedAggregationCoarseSolver, Pinv).\nargs...: Additional arguments for the coarse solver.\nkwargs...: Additional keyword arguments for the coarse solver.\n\n\n\n\n\n","category":"function"},{"location":"#FerriteMultigrid","page":"Home","title":"FerriteMultigrid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FerriteMultigrid.jl is a lightweight, flexible p-multigrid framework designed for high-order finite element problems in Julia.   It is built on top of Ferrite.jl and leverages AlgebraicMultigrid.jl as the coarse-grid solver once the approximation is reduced to ( p = 1 ).","category":"page"},{"location":"#How-the-documentation-is-organized","page":"Home","title":"How the documentation is organized","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This high level view of the documentation structure will help you find what you are looking for. The document is organized as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials are thoroughly documented examples which guides you through the process of solving finite element problems using p- and A- multigrid methods.\nAPI Reference contains the technical API reference of functions and methods (e.g. the documentation strings).","category":"page"}]
}
